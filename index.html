<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Executive Decision</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="game-container">
        <div id="start-screen" class="screen">
            <div class="logo">
                <h1>Executive Decision</h1>
                <h2>Run Pretty Close Centres to corporate glory... or ruin</h2>
            </div>
            <button id="start-button" class="primary-button">Start New Game</button>
            <button id="load-button" class="secondary-button">Load Game</button>
            <div class="footer">
                <p>A corporate decision-making game</p>
            </div>
        </div>

        <div id="game-screen" class="screen hidden">
            <div id="header">
                <div id="year-display">Year: <span id="year">1</span> Week: <span id="week">1</span>/52</div>
                <div id="company-name">Pretty Close Centres</div>
                <div id="money-display">$<span id="money-value">10000000</span></div>
                <div id="menu-button">≡</div>
            </div>

            <div id="metrics-panel">
                <div class="metric-group">
                    <h3>Core Business</h3>
                    <div class="metric" id="revenue">
                        <span class="metric-label">Revenue</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="employee-engagement">
                        <span class="metric-label">Employee Engagement</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="customer-satisfaction">
                        <span class="metric-label">Customer Satisfaction</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                </div>

                <div class="metric-group collapsible" id="values-metrics">
                    <h3>Corporate Values</h3>
                    <div class="metric" id="respect">
                        <span class="metric-label">Respect</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="integrity">
                        <span class="metric-label">Integrity</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="collaboration">
                        <span class="metric-label">Collaboration</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="customer-focus">
                        <span class="metric-label">Customer Focus</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="excellence">
                        <span class="metric-label">Excellence</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                </div>

                <div class="metric-group collapsible" id="faction-metrics">
                    <h3>Faction Reputation</h3>
                    <div class="metric" id="banks">
                        <span class="metric-label">Banks</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="co-owners">
                        <span class="metric-label">Co-owners</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="regulators">
                        <span class="metric-label">Regulators</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="government">
                        <span class="metric-label">Government</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                    <div class="metric" id="security-holders">
                        <span class="metric-label">Security Holders</span>
                        <div class="meter-container">
                            <div class="meter" style="width: 50%;"></div>
                        </div>
                        <span class="metric-value">50</span>
                    </div>
                </div>
            </div>

            <div id="scenario-container">
                <div id="scenario-card">
                    <div id="scenario-image"></div>
                    <div id="scenario-content">
                        <h3 id="scenario-title">Scenario Title</h3>
                        <p id="scenario-description">Scenario description goes here...</p>
                        <div id="scenario-money-cost" class="hidden">
                            <p><strong>Cost: $<span id="money-cost-value">0</span></strong></p>
                        </div>
                    </div>
                </div>
                <div id="choices-container">
                    <!-- Choices will be generated dynamically -->
                </div>
            </div>

            <div id="news-feed-container">
                <div id="news-feed-header">
                    <h3>News Feed</h3>
                    <button id="news-feed-toggle">▲</button>
                </div>
                <div id="news-feed-content">
                    <!-- News feed entries will be added here -->
                    <div class="news-entry welcome-entry">
                        <span class="news-date">Year 1, Week 1</span>
                        <p>Welcome to Pretty Close Centres. Your decisions will shape the future of the company.</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h2>Game Over</h2>
            <p id="game-over-reason">Game over reason goes here</p>
            <div id="final-stats">
                <h3>Final Stats</h3>
                <div id="final-stats-content"></div>
                <div id="final-score">
                    <h3>Years Survived: <span id="years-survived">0</span></h3>
                </div>
            </div>
            <button id="restart-button" class="primary-button">Play Again</button>
            <button id="main-menu-button" class="secondary-button">Main Menu</button>
        </div>

        <div id="menu-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Menu</h2>
                <button id="save-game-button" class="menu-button">Save Game</button>
                <button id="menu-load-button" class="menu-button">Load Game</button>
                <button id="view-stats-button" class="menu-button">View Stats</button>
                <button id="view-bonuses-button" class="menu-button">View Bonuses</button>
                <button id="view-flags-button" class="menu-button">View Active Flags</button>
                <button id="view-scenario-packs-button" class="menu-button">View Scenario Packs</button>
                <button id="close-menu-button" class="menu-button">Close Menu</button>
                <button id="quit-button" class="menu-button danger">Quit to Main Menu</button>
            </div>
        </div>

        <div id="stats-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Company Statistics</h2>
                <div id="stats-content"></div>
                <button id="close-stats-button" class="menu-button">Close</button>
            </div>
        </div>

        <div id="bonuses-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Available Bonuses</h2>
                <div id="bonuses-content">
                    <p>Loading bonuses...</p>
                </div>
                <button id="close-bonuses-button" class="menu-button">Close</button>
            </div>
        </div>

        <div id="flags-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Active Company Status</h2>
                <div id="flags-content">
                    <p>Loading flags...</p>
                </div>
                <button id="close-flags-button" class="menu-button">Close</button>
            </div>
        </div>

        <div id="scenario-packs-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Scenario Packs</h2>
                <div id="scenario-packs-content">
                    <p>Loading scenario packs...</p>
                </div>
                <button id="close-scenario-packs-button" class="menu-button">Close</button>
            </div>
        </div>

        <div id="year-report-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Annual Report - Year <span id="annual-report-year">1</span></h2>
                <div id="annual-report-content">
                    <!-- Annual report content will be generated dynamically -->
                </div>
                <div id="distribution-decision" class="hidden">
                    <h3>Security Holder Distribution</h3>
                    <p>Choose how much to distribute to security holders:</p>
                    <div id="distribution-options">
                        <!-- Distribution options will be generated dynamically -->
                    </div>
                </div>
                <button id="continue-year-button" class="primary-button">Continue to Next Year</button>
            </div>
        </div>

        <div id="money-crisis-overlay" class="overlay hidden">
            <div class="overlay-content">
                <h2>Financial Crisis</h2>
                <p>Your company has run out of money. You must take immediate action:</p>
                <div id="money-crisis-options">
                    <button id="raise-debt-button" class="menu-button">Raise Debt</button>
                    <p class="option-description">Significantly impact your standing with Banks and reduce financial performance due to interest burden.</p>
                    
                    <button id="raise-equity-button" class="menu-button">Raise Equity</button>
                    <p class="option-description">Impact depends on your standing with security holders and will negatively affect your reputation.</p>
                    
                    <button id="sell-assets-button" class="menu-button">Sell Assets</button>
                    <p class="option-description">Significantly reduce future financial performance by removing revenue streams.</p>
                </div>
            </div>
        </div>

        <div id="notification" class="hidden">
            <p id="notification-message"></p>
        </div>
    </div>

    <script>
        // Core Game Logic
        class GameState {
            constructor() {
                // Initialize core business metrics
                this.metrics = {
                    revenue: 50,
                    employeeEngagement: 50,
                    customerSatisfaction: 50
                };

                // Initialize corporate values
                this.values = {
                    respect: 50,
                    integrity: 50,
                    collaboration: 50,
                    customerFocus: 50,
                    excellence: 50
                };

                // Initialize faction reputations
                this.factions = {
                    banks: 50,
                    coOwners: 50,
                    regulators: 50,
                    government: 50,
                    securityHolders: 50
                };

                // Game progression
                this.year = 1;
                this.week = 1;
                this.scenariosHandled = 0;
                this.activeBonuses = [];

                // Money (in millions)
                this.money = 10000000; // $10 million start

                // Game state flags (human readable phrases)
                this.flags = {};
                
                // Map of opposite/mutually exclusive flags
                this.oppositeFlags = {
                    "The company has a conservative risk appetite.": "The company has an aggressive risk appetite.",
                    "The company has an aggressive risk appetite.": "The company has a conservative risk appetite.",
                    "The company prioritizes financial performance.": "The company prioritizes social impact.",
                    "The company prioritizes social impact.": "The company prioritizes financial performance.",
                    "The company has become purpose driven.": "The company is shareholder focused.",
                    "The company is shareholder focused.": "The company has become purpose driven.",
                    // Add more opposite pairs as needed
                };
                
                // News feed entries
                this.newsFeed = [{
                    year: 1,
                    week: 1,
                    title: "First Day at Pretty Close Centres",
                    description: "You've begun your role as an executive at Pretty Close Centres, an ASX-listed company specializing in shopping centers.",
                    impacts: []
                }];
                
                // Statistics
                this.stats = {
                    decisionsPerYear: {},
                    metricHistory: {},
                    flagsTriggered: [],
                    moneyHistory: {},
                    yearEvents: []
                };
            }

            // Apply scenario outcome effects
            applyOutcome(outcome, choiceText, scenarioTitle) {
                let effects = {
                    metrics: {},
                    values: {},
                    factions: {},
                    flags: [],
                    money: 0
                };

                let impactDescriptions = [];

                // Apply money cost if present
                if (outcome.moneyCost) {
                    const cost = outcome.moneyCost;
                    this.money -= cost;
                    effects.money = -cost;
                    impactDescriptions.push(`Spent $${this.formatMoney(cost)}`);
                }

                // Apply effects to metrics
                if (outcome.metrics) {
                    for (const [metric, change] of Object.entries(outcome.metrics)) {
                        const mappedMetric = this.mapMetricName(metric);
                        if (this.metrics.hasOwnProperty(mappedMetric)) {
                            const originalValue = this.metrics[mappedMetric];
                            
                            // Check for very impactful scenario (double or halve)
                            let actualChange = change;
                            if (outcome.veryImpactful) {
                                if (change > 0) {
                                    // Double the metric (max 100)
                                    actualChange = originalValue;
                                    this.metrics[mappedMetric] = Math.min(100, originalValue * 2);
                                } else if (change < 0) {
                                    // Halve the metric (rounded up)
                                    actualChange = -Math.ceil(originalValue / 2);
                                    this.metrics[mappedMetric] = Math.ceil(originalValue / 2);
                                }
                            } else {
                                // Normal impact
                                this.metrics[mappedMetric] = Math.max(0, Math.min(100, originalValue + actualChange));
                            }
                            
                            effects.metrics[mappedMetric] = {
                                previous: originalValue,
                                change: actualChange,
                                current: this.metrics[mappedMetric]
                            };
                            
                            // Add to impact descriptions
                            const displayMetric = this.getDisplayName(mappedMetric);
                            if (actualChange !== 0) {
                                const direction = actualChange > 0 ? "increased" : "decreased";
                                impactDescriptions.push(`${displayMetric} ${direction} by ${Math.abs(actualChange)} points`);
                            }
                        }
                    }
                }

                // Apply effects to values
                if (outcome.values) {
                    for (const [value, change] of Object.entries(outcome.values)) {
                        const mappedValue = this.mapValueName(value);
                        if (this.values.hasOwnProperty(mappedValue)) {
                            const originalValue = this.values[mappedValue];
                            
                            // Check for very impactful scenario
                            let actualChange = change;
                            if (outcome.veryImpactful) {
                                if (change > 0) {
                                    // Double the value (max 100)
                                    actualChange = originalValue;
                                    this.values[mappedValue] = Math.min(100, originalValue * 2);
                                } else if (change < 0) {
                                    // Halve the value (rounded up)
                                    actualChange = -Math.ceil(originalValue / 2);
                                    this.values[mappedValue] = Math.ceil(originalValue / 2);
                                }
                            } else {
                                // Normal impact
                                this.values[mappedValue] = Math.max(0, Math.min(100, originalValue + actualChange));
                            }
                            
                            effects.values[mappedValue] = {
                                previous: originalValue,
                                change: actualChange,
                                current: this.values[mappedValue]
                            };
                            
                            // Add to impact descriptions
                            const displayValue = this.getDisplayName(mappedValue);
                            if (actualChange !== 0) {
                                const direction = actualChange > 0 ? "strengthened" : "weakened";
                                impactDescriptions.push(`${displayValue} value ${direction} by ${Math.abs(actualChange)} points`);
                                
                                // Check for strong alignment or misalignment with values
                                if (Math.abs(actualChange) >= 3) {
                                    const alignment = actualChange > 0 ? "strongly aligned with" : "contradicted";
                                    impactDescriptions.push(`This decision ${alignment} our ${displayValue} value`);
                                }
                            }
                        }
                    }
                }

                // Apply effects to factions
                if (outcome.factions) {
                    for (const [faction, change] of Object.entries(outcome.factions)) {
                        const mappedFaction = this.mapFactionName(faction);
                        if (this.factions.hasOwnProperty(mappedFaction)) {
                            const originalValue = this.factions[mappedFaction];
                            
                            // Check for very impactful scenario
                            let actualChange = change;
                            if (outcome.veryImpactful) {
                                if (change > 0) {
                                    // Double the faction (max 100)
                                    actualChange = originalValue;
                                    this.factions[mappedFaction] = Math.min(100, originalValue * 2);
                                } else if (change < 0) {
                                    // Halve the faction (rounded up)
                                    actualChange = -Math.ceil(originalValue / 2);
                                    this.factions[mappedFaction] = Math.ceil(originalValue / 2);
                                }
                            } else {
                                // Normal impact
                                this.factions[mappedFaction] = Math.max(0, Math.min(100, originalValue + actualChange));
                            }
                            
                            effects.factions[mappedFaction] = {
                                previous: originalValue,
                                change: actualChange,
                                current: this.factions[mappedFaction]
                            };
                            
                            // Add to impact descriptions
                            const displayFaction = this.getDisplayName(mappedFaction);
                            if (actualChange !== 0) {
                                const direction = actualChange > 0 ? "improved" : "deteriorated";
                                impactDescriptions.push(`Relationship with ${displayFaction} ${direction} by ${Math.abs(actualChange)} points`);
                            }
                        }
                    }
                }

                // Set flags
                if (outcome.flags) {
                    for (const flag of outcome.flags) {
                        // Add flag and handle opposites
                        this.setFlag(flag);
                        effects.flags.push(flag);
                        
                        // Add to descriptions
                        impactDescriptions.push(flag);
                        
                        if (!this.stats.flagsTriggered.includes(flag)) {
                            this.stats.flagsTriggered.push(flag);
                        }
                    }
                }

                // Calculate money earned based on revenue and other factors
                if (this.week % 13 === 0) { // Quarterly financial update
                    const baseEarnings = (this.metrics.revenue / 100) * 1000000; // Up to $1M per quarter at max revenue
                    const adjustedEarnings = baseEarnings * 
                        (0.8 + (this.factions.securityHolders / 500)); // Security holder relationship affects earnings
                    
                    this.money += adjustedEarnings;
                    effects.money = adjustedEarnings;
                    impactDescriptions.push(`Quarterly earnings: $${this.formatMoney(adjustedEarnings)}`);
                }

                // Add news feed entry
                this.addNewsFeedEntry(scenarioTitle, choiceText, impactDescriptions);

                // Track statistics
                this.scenariosHandled++;
                this.week++;
                
                if (!this.stats.decisionsPerYear[this.year]) {
                    this.stats.decisionsPerYear[this.year] = 0;
                }
                this.stats.decisionsPerYear[this.year]++;

                // Check for year advancement (after 52 scenarios/weeks)
                if (this.week > 52) {
                    this.advanceYear();
                }

                // Check for any max value bonuses
                this.checkForBonuses();

                return effects;
            }

            // Add entry to news feed
            addNewsFeedEntry(title, decision, impacts) {
                const entry = {
                    year: this.year,
                    week: this.week,
                    title: title,
                    decision: decision,
                    impacts: impacts,
                    timestamp: new Date()
                };
                
                this.newsFeed.unshift(entry); // Add to beginning for reverse chronological order
                
                // Limit feed length to prevent excessive memory use
                if (this.newsFeed.length > 200) {
                    this.newsFeed = this.newsFeed.slice(0, 200);
                }
                
                return entry;
            }
            
            // Set a flag and handle opposites
            setFlag(flag) {
                this.flags[flag] = true;
                
                // Check for opposite flags
                if (this.oppositeFlags[flag] && this.flags[this.oppositeFlags[flag]]) {
                    delete this.flags[this.oppositeFlags[flag]];
                }
            }

            // Format money values
            formatMoney(amount) {
                if (Math.abs(amount) >= 1000000) {
                    return (amount / 1000000).toFixed(2) + 'M';
                } else if (Math.abs(amount) >= 1000) {
                    return (amount / 1000).toFixed(2) + 'K';
                } else {
                    return amount.toFixed(2);
                }
            }

            // Helper method to map metric names from scenarios to property names
            mapMetricName(metricName) {
                const metricMap = {
                    'revenue': 'revenue',
                    'employee_engagement': 'employeeEngagement',
                    'customer_satisfaction': 'customerSatisfaction'
                };
                return metricMap[metricName] || metricName;
            }

            // Helper method to map value names from scenarios to property names
            mapValueName(valueName) {
                const valueMap = {
                    'respect': 'respect',
                    'integrity': 'integrity',
                    'collaboration': 'collaboration',
                    'customer_focus': 'customerFocus',
                    'excellence': 'excellence'
                };
                return valueMap[valueName] || valueName;
            }

            // Helper method to map faction names from scenarios to property names
            mapFactionName(factionName) {
                const factionMap = {
                    'banks': 'banks',
                    'co_owners': 'coOwners',
                    'regulators': 'regulators',
                    'government': 'government',
                    'security_holders': 'securityHolders'
                };
                return factionMap[factionName] || factionName;
            }

            // Get display names for metrics, values, factions
            getDisplayName(key) {
                const displayNames = {
                    // Metrics
                    revenue: 'Revenue',
                    employeeEngagement: 'Employee Engagement',
                    customerSatisfaction: 'Customer Satisfaction',
                    
                    // Values
                    respect: 'Respect',
                    integrity: 'Integrity',
                    collaboration: 'Collaboration',
                    customerFocus: 'Customer Focus',
                    excellence: 'Excellence',
                    
                    // Factions
                    banks: 'Banks',
                    coOwners: 'Co-owners',
                    regulators: 'Regulators',
                    government: 'Government',
                    securityHolders: 'Security Holders'
                };
                
                return displayNames[key] || key;
            }

            // Advance to the next year
            advanceYear() {
                // Get year-end snapshot before advancing
                const yearEndSnapshot = {
                    year: this.year,
                    metrics: {...this.metrics},
                    values: {...this.values},
                    factions: {...this.factions},
                    money: this.money,
                    flags: {...this.flags}
                };
                
                // Save current metrics to history
                this.recordMetricHistory(yearEndSnapshot);
                
                // Reset week counter
                this.week = 1;
                
                // Advance year
                this.year++;
                
                // Add year transition news entry
                this.addNewsFeedEntry(
                    "Annual Report", 
                    `Year ${this.year-1} has concluded`,
                    [`Starting Year ${this.year}`]
                );
                
                // Return the year-end snapshot for the annual report
                return yearEndSnapshot;
            }

            // Record metric history for charts/statistics
            recordMetricHistory(yearEndSnapshot) {
                this.stats.metricHistory[this.year] = {
                    metrics: {...this.metrics},
                    values: {...this.values},
                    factions: {...this.factions}
                };
                
                this.stats.moneyHistory[this.year] = this.money;
            }

            // Check for any bonuses from maxed metrics/values
            checkForBonuses() {
                let newBonuses = [];
                
                // Check core metrics
                for (const [metric, value] of Object.entries(this.metrics)) {
                    if (value >= 100 && !this.activeBonuses.includes(`${metric}_max`)) {
                        this.activeBonuses.push(`${metric}_max`);
                        newBonuses.push(`${metric}_max`);
                    }
                }
                
                // Check values
                for (const [value, rating] of Object.entries(this.values)) {
                    if (rating >= 100 && !this.activeBonuses.includes(`${value}_max`)) {
                        this.activeBonuses.push(`${value}_max`);
                        newBonuses.push(`${value}_max`);
                    }
                }
                
                // Check factions
                for (const [faction, rating] of Object.entries(this.factions)) {
                    if (rating >= 100 && !this.activeBonuses.includes(`${faction}_max`)) {
                        this.activeBonuses.push(`${faction}_max`);
                        newBonuses.push(`${faction}_max`);
                    }
                }
                
                return newBonuses;
            }

            // Handle security holder distribution decision
            makeDistribution(amount) {
                if (amount > this.money) {
                    return {success: false, message: "Insufficient funds for this distribution."};
                }
                
                this.money -= amount;
                
                // Calculate impact on security holder reputation
                let reputationChange = 0;
                const expectedDistribution = (this.metrics.revenue / 100) * 2000000; // Scale with revenue
                
                if (amount >= expectedDistribution * 1.2) {
                    // Generous distribution
                    reputationChange = 5;
                } else if (amount >= expectedDistribution * 0.8) {
                    // Expected range
                    reputationChange = 3;
                } else if (amount >= expectedDistribution * 0.5) {
                    // Below expectations
                    reputationChange = -1;
                } else {
                    // Significantly below expectations
                    reputationChange = -3;
                }
                
                // Apply reputation change
                this.factions.securityHolders = Math.max(0, Math.min(100, this.factions.securityHolders + reputationChange));
                
                // Add to news feed
                this.addNewsFeedEntry(
                    "Security Holder Distribution",
                    `Distributed $${this.formatMoney(amount)} to security holders`,
                    [
                        `Security Holder reputation ${reputationChange >= 0 ? 'increased' : 'decreased'} by ${Math.abs(reputationChange)} points`
                    ]
                );
                
                return {
                    success: true, 
                    message: `Successfully distributed $${this.formatMoney(amount)} to security holders.`,
                    reputationChange: reputationChange
                };
            }

            // Handle financial crisis options
            handleFinancialCrisis(option) {
                const result = {
                    success: true,
                    effects: {
                        metrics: {},
                        factions: {},
                        money: 0
                    },
                    message: ""
                };
                
                switch(option) {
                    case "debt":
                        // Raise debt
                        const debtAmount = 10000000; // $10M
                        this.money += debtAmount;
                        result.effects.money = debtAmount;
                        
                        // Impact on Banks and financial performance
                        const originalBanks = this.factions.banks;
                        const originalRevenue = this.metrics.revenue;
                        
                        this.factions.banks = Math.max(0, this.factions.banks - 15);
                        this.metrics.revenue = Math.max(0, this.metrics.revenue - 10);
                        
                        result.effects.factions.banks = {
                            previous: originalBanks,
                            change: -15,
                            current: this.factions.banks
                        };
                        
                        result.effects.metrics.revenue = {
                            previous: originalRevenue,
                            change: -10,
                            current: this.metrics.revenue
                        };
                        
                        result.message = "Raised $10M in debt. Relationship with Banks has suffered significantly and interest payments will reduce financial performance.";
                        
                        // Set debt flag
                        this.setFlag("The company is carrying significant debt.");
                        break;
                        
                    case "equity":
                        // Raise equity
                        const equityAmount = 15000000; // $15M
                        this.money += equityAmount;
                        result.effects.money = equityAmount;
                        
                        // Impact depends on security holder reputation
                        const reputationImpact = this.factions.securityHolders > 70 ? -5 : 
                                               (this.factions.securityHolders > 40 ? -10 : -20);
                        
                        const originalSecurityHolders = this.factions.securityHolders;
                        this.factions.securityHolders = Math.max(0, this.factions.securityHolders + reputationImpact);
                        
                        result.effects.factions.securityHolders = {
                            previous: originalSecurityHolders,
                            change: reputationImpact,
                            current: this.factions.securityHolders
                        };
                        
                        result.message = `Raised $15M through equity issuance. Security Holder reputation ${reputationImpact >= 0 ? 'increased' : 'decreased'} by ${Math.abs(reputationImpact)} points.`;
                        
                        // Set equity dilution flag
                        this.setFlag("The company has recently diluted equity.");
                        break;
                        
                    case "assets":
                        // Sell assets
                        const assetSaleAmount = 20000000; // $20M
                        this.money += assetSaleAmount;
                        result.effects.money = assetSaleAmount;
                        
                        // Significant impact on future revenue
                        const originalRevenue2 = this.metrics.revenue;
                        this.metrics.revenue = Math.max(0, this.metrics.revenue - 25);
                        
                        result.effects.metrics.revenue = {
                            previous: originalRevenue2,
                            change: -25,
                            current: this.metrics.revenue
                        };
                        
                        result.message = "Sold key assets for $20M. Future financial performance will be significantly reduced due to lost revenue streams.";
                        
                        // Set asset sale flag
                        this.setFlag("The company has sold off key assets.");
                        break;
                }
                
                // Add to news feed
                this.addNewsFeedEntry(
                    "Financial Crisis Response",
                    result.message,
                    Object.entries(result.effects.metrics).map(([metric, data]) => {
                        const displayMetric = this.getDisplayName(metric);
                        const direction = data.change > 0 ? "increased" : "decreased";
                        return `${displayMetric} ${direction} by ${Math.abs(data.change)} points`;
                    }).concat(
                        Object.entries(result.effects.factions).map(([faction, data]) => {
                            const displayFaction = this.getDisplayName(faction);
                            const direction = data.change > 0 ? "improved" : "deteriorated";
                            return `Relationship with ${displayFaction} ${direction} by ${Math.abs(data.change)} points`;
                        })
                    )
                );
                
                return result;
            }

            // Check if game over
            isGameOver() {
                // Check if any core metrics are at 0
                for (const value of Object.values(this.metrics)) {
                    if (value <= 0) return true;
                }
                
                // Check if any values are at 0
                for (const value of Object.values(this.values)) {
                    if (value <= 0) return true;
                }
                
                // Check if any faction reputations are at 0
                for (const value of Object.values(this.factions)) {
                    if (value <= 0) return true;
                }
                
                return false;
            }

            // Get reason for game over
            getGameOverReason() {
                // Check core metrics
                for (const [metric, value] of Object.entries(this.metrics)) {
                    if (value <= 0) {
                        switch(metric) {
                            case 'revenue':
                                return "Your company went bankrupt due to insufficient revenue.";
                            case 'employeeEngagement':
                                return "Your employees lost all motivation and began leaving en masse.";
                            case 'customerSatisfaction':
                                return "Your shopping centres became ghost towns as customers abandoned you.";
                        }
                    }
                }
                
                // Check values
                for (const [value, rating] of Object.entries(this.values)) {
                    if (rating <= 0) {
                        switch(value) {
                            case 'respect':
                                return "Your company's toxic culture led to a catastrophic talent exodus.";
                            case 'integrity':
                                return "Your company's unethical practices resulted in criminal charges.";
                            case 'collaboration':
                                return "Your siloed organization collapsed under its inability to coordinate.";
                            case 'customerFocus':
                                return "Your company's disregard for customers led to a complete market rejection.";
                            case 'excellence':
                                return "Your company's substandard practices led to critical failures across operations.";
                        }
                    }
                }
                
                // Check factions
                for (const [faction, rating] of Object.entries(this.factions)) {
                    if (rating <= 0) {
                        switch(faction) {
                            case 'banks':
                                return "The banks called in their loans, forcing your company into receivership.";
                            case 'coOwners':
                                return "Your joint venture partners sued for breach of contract, destroying the company.";
                            case 'regulators':
                                return "Regulatory bodies suspended your operating licenses indefinitely.";
                            case 'government':
                                return "Government intervention blocked all your development plans.";
                            case 'securityHolders':
                                return "A shareholder revolt ousted you from leadership.";
                        }
                    }
                }
                
                return "Your company failed due to mismanagement.";
            }

            // Save game state
            save() {
                const saveData = {
                    metrics: this.metrics,
                    values: this.values,
                    factions: this.factions,
                    year: this.year,
                    week: this.week,
                    scenariosHandled: this.scenariosHandled,
                    activeBonuses: this.activeBonuses,
                    flags: this.flags,
                    money: this.money,
                    newsFeed: this.newsFeed,
                    stats: this.stats,
                    oppositeFlags: this.oppositeFlags
                };
                
                localStorage.setItem('executiveDecisionSave', JSON.stringify(saveData));
                return true;
            }

            // Load game state
            load() {
                const saveData = localStorage.getItem('executiveDecisionSave');
                if (!saveData) return false;
                
                const parsedData = JSON.parse(saveData);
                
                this.metrics = parsedData.metrics;
                this.values = parsedData.values;
                this.factions = parsedData.factions;
                this.year = parsedData.year;
                this.week = parsedData.week;
                this.scenariosHandled = parsedData.scenariosHandled;
                this.activeBonuses = parsedData.activeBonuses;
                this.flags = parsedData.flags;
                this.money = parsedData.money;
                this.newsFeed = parsedData.newsFeed;
                this.stats = parsedData.stats;
                this.oppositeFlags = parsedData.oppositeFlags;
                
                return true;
            }

            // Get a serializable copy of the game state
            getState() {
                return {
                    metrics: {...this.metrics},
                    values: {...this.values},
                    factions: {...this.factions},
                    year: this.year,
                    week: this.week,
                    scenariosHandled: this.scenariosHandled,
                    activeBonuses: [...this.activeBonuses],
                    flags: {...this.flags},
                    money: this.money,
                    newsFeed: [...this.newsFeed],
                    stats: JSON.parse(JSON.stringify(this.stats))
                };
            }
        }

        class ScenarioManager {
            constructor(gameState) {
                this.gameState = gameState;
                this.scenarios = [];
                this.usedScenarios = new Set();
                this.startingScenario = null;
            }

            // Set available scenarios
            setScenarios(scenarios) {
                this.scenarios = scenarios;
                
                // Look for and set aside the starting scenario
                const startingIndex = this.scenarios.findIndex(scenario => scenario.id === "starting_scenario");
                if (startingIndex !== -1) {
                    this.startingScenario = this.scenarios.splice(startingIndex, 1)[0];
                }
            }

            // Get the first scenario (special starting scenario)
            getStartingScenario() {
                if (this.startingScenario) {
                    return this.startingScenario;
                }
                
                // If no dedicated starting scenario exists, create one
                return {
                    id: "default_starting_scenario",
                    title: "Your First Day as Executive",
                    description: "As you settle into your new office at Pretty Close Centres, the board has asked you to establish your strategic priorities for the coming years. Your initial direction will set the tone for your leadership.",
                    image: "office.jpg",
                    choices: [
                        {
                            text: "Focus on financial growth and shareholder returns",
                            explanation: "You pledge to prioritize revenue growth and returns to shareholders above all else.",
                            outcome: {
                                metrics: { revenue: 10, employee_engagement: 3, customer_satisfaction: -5 },
                                values: { excellence: 5, customer_focus: -3, integrity: -2 },
                                factions: { security_holders: 10, banks: 8, regulators: -5 },
                                flags: ["The company prioritizes financial performance.", "The company is shareholder focused."]
                            }
                        },
                        {
                            text: "Build a balanced business with strong stakeholder relationships",
                            explanation: "You commit to a balanced approach that considers all stakeholders in your decision making.",
                            outcome: {
                                metrics: { revenue: 5, employee_engagement: 5, customer_satisfaction: 5 },
                                values: { respect: 5, integrity: 5, collaboration: 5, customer_focus: 5, excellence: 5 },
                                factions: { security_holders: 5, co_owners: 5, regulators: 5, government: 5, banks: 5 },
                                flags: ["The company takes a balanced approach to stakeholders."]
                            }
                        },
                        {
                            text: "Establish a purpose-driven organization focused on community impact",
                            explanation: "You declare that Pretty Close Centres will measure success by its positive impact on communities and society.",
                            outcome: {
                                metrics: { revenue: -5, employee_engagement: 10, customer_satisfaction: 10 },
                                values: { respect: 8, integrity: 8, customer_focus: 7, collaboration: 5, excellence: 2 },
                                factions: { government: 10, regulators: 7, co_owners: 5, security_holders: -8 },
                                flags: ["The company has become purpose driven.", "The company prioritizes social impact."]
                            }
                        }
                    ]
                };
            }

            // Get the next scenario based on conditions
            getNextScenario() {
                // Special case: if this is the first scenario, return the starting scenario
                if (this.gameState.scenariosHandled === 0) {
                    return this.getStartingScenario();
                }
                
                // Filter scenarios based on conditions
                const eligibleScenarios = this.scenarios.filter(scenario => {
                    // Skip used scenarios unless they're repeatable
                    if (this.usedScenarios.has(scenario.id) && !scenario.repeatable) {
                        return false;
                    }
                    
                    // Check conditions
                    if (scenario.conditions) {
                        // Check year range
                        if (scenario.conditions.minYear && this.gameState.year < scenario.conditions.minYear) {
                            return false;
                        }
                        if (scenario.conditions.maxYear && this.gameState.year > scenario.conditions.maxYear) {
                            return false;
                        }
                        
                        // Check week range
                        if (scenario.conditions.minWeek && this.gameState.week < scenario.conditions.minWeek) {
                            return false;
                        }
                        if (scenario.conditions.maxWeek && this.gameState.week > scenario.conditions.maxWeek) {
                            return false;
                        }
                        
                        // Check required flags
                        if (scenario.conditions.requiredFlags) {
                            for (const flag of scenario.conditions.requiredFlags) {
                                if (!this.gameState.flags[flag]) {
                                    return false;
                                }
                            }
                        }
                        
                        // Check excluded flags
                        if (scenario.conditions.excludedFlags) {
                            for (const flag of scenario.conditions.excludedFlags) {
                                if (this.gameState.flags[flag]) {
                                    return false;
                                }
                            }
                        }
                        
                        // Check metric ranges
                        if (scenario.conditions.metrics) {
                            for (const [metric, range] of Object.entries(scenario.conditions.metrics)) {
                                const mappedMetric = this.gameState.mapMetricName(metric);
                                const value = this.gameState.metrics[mappedMetric];
                                if (range.min !== undefined && value < range.min) {
                                    return false;
                                }
                                if (range.max !== undefined && value > range.max) {
                                    return false;
                                }
                            }
                        }
                        
                        // Check value ranges
                        if (scenario.conditions.values) {
                            for (const [value, range] of Object.entries(scenario.conditions.values)) {
                                const mappedValue = this.gameState.mapValueName(value);
                                const rating = this.gameState.values[mappedValue];
                                if (range.min !== undefined && rating < range.min) {
                                    return false;
                                }
                                if (range.max !== undefined && rating > range.max) {
                                    return false;
                                }
                            }
                        }
                        
                        // Check faction ranges
                        if (scenario.conditions.factions) {
                            for (const [faction, range] of Object.entries(scenario.conditions.factions)) {
                                const mappedFaction = this.gameState.mapFactionName(faction);
                                const rating = this.gameState.factions[mappedFaction];
                                if (range.min !== undefined && rating < range.min) {
                                    return false;
                                }
                                if (range.max !== undefined && rating > range.max) {
                                    return false;
                                }
                            }
                        }
                        
                        // Check money range
                        if (scenario.conditions.money) {
                            const money = this.gameState.money;
                            if (scenario.conditions.money.min !== undefined && money < scenario.conditions.money.min) {
                                return false;
                            }
                            if (scenario.conditions.money.max !== undefined && money > scenario.conditions.money.max) {
                                return false;
                            }
                        }
                    }
                    
                    // Scenario is eligible
                    return true;
                });
                
                // If no eligible scenarios, use a default one
                if (eligibleScenarios.length === 0) {
                    return this.getDefaultScenario();
                }
                
                // Apply priority and weights to select scenario
                let totalWeight = 0;
                const weightedScenarios = eligibleScenarios.map(scenario => {
                    const priority = scenario.priority || 1;
                    const weight = scenario.weight || 1;
                    const effectiveWeight = weight * priority;
                    totalWeight += effectiveWeight;
                    return {
                        scenario,
                        weight: effectiveWeight
                    };
                });
                
                // Select scenario based on weights
                let random = Math.random() * totalWeight;
                let selectedScenario = null;
                
                for (const { scenario, weight } of weightedScenarios) {
                    random -= weight;
                    if (random <= 0) {
                        selectedScenario = scenario;
                        break;
                    }
                }
                
                // If something went wrong, use the first eligible scenario
                if (!selectedScenario) {
                    selectedScenario = eligibleScenarios[0];
                }
                
                // Mark scenario as used
                this.usedScenarios.add(selectedScenario.id);
                
                return selectedScenario;
            }

            // Get a default/fallback scenario
            getDefaultScenario() {
                // Create a simple default scenario
                return {
                    id: "default_scenario",
                    title: "Daily Operations",
                    description: "Another day managing Pretty Close Centres. What will you focus on today?",
                    image: "office.jpg",
                    choices: [
                        {
                            text: "Focus on financial performance",
                            outcome: {
                                metrics: { revenue: 3, employee_engagement: -1 },
                                values: { excellence: 2, customer_focus: -1 }
                            }
                        },
                        {
                            text: "Focus on employee welfare",
                            outcome: {
                                metrics: { revenue: -1, employee_engagement: 3 },
                                values: { respect: 2, excellence: -1 }
                            }
                        },
                        {
                            text: "Focus on customer experience",
                            outcome: {
                                metrics: { revenue: 1, customer_satisfaction: 3 },
                                values: { customer_focus: 2, collaboration: 1 }
                            }
                        }
                    ]
                };
            }

            // Reset used scenarios (e.g., on year change)
            resetUsedScenarios() {
                this.usedScenarios.clear();
            }
        }

        class Game {
            constructor() {
                this.gameState = new GameState();
                this.scenarioManager = new ScenarioManager(this.gameState);
                this.currentScenario = null;
                this.isRunning = false;
                this.awaitingYearEnd = false;
                this.awaitingMoneyCrisis = false;
                
                // UI elements
                this.elements = {
                    screens: {
                        start: document.getElementById('start-screen'),
                        game: document.getElementById('game-screen'),
                        gameOver: document.getElementById('game-over-screen')
                    },
                    metrics: {
                        revenue: {
                            meter: document.querySelector('#revenue .meter'),
                            value: document.querySelector('#revenue .metric-value')
                        },
                        employeeEngagement: {
                            meter: document.querySelector('#employee-engagement .meter'),
                            value: document.querySelector('#employee-engagement .metric-value')
                        },
                        customerSatisfaction: {
                            meter: document.querySelector('#customer-satisfaction .meter'),
                            value: document.querySelector('#customer-satisfaction .metric-value')
                        }
                    },
                    values: {
                        respect: {
                            meter: document.querySelector('#respect .meter'),
                            value: document.querySelector('#respect .metric-value')
                        },
                        integrity: {
                            meter: document.querySelector('#integrity .meter'),
                            value: document.querySelector('#integrity .metric-value')
                        },
                        collaboration: {
                            meter: document.querySelector('#collaboration .meter'),
                            value: document.querySelector('#collaboration .metric-value')
                        },
                        customerFocus: {
                            meter: document.querySelector('#customer-focus .meter'),
                            value: document.querySelector('#customer-focus .metric-value')
                        },
                        excellence: {
                            meter: document.querySelector('#excellence .meter'),
                            value: document.querySelector('#excellence .metric-value')
                        }
                    },
                    factions: {
                        banks: {
                            meter: document.querySelector('#banks .meter'),
                            value: document.querySelector('#banks .metric-value')
                        },
                        coOwners: {
                            meter: document.querySelector('#co-owners .meter'),
                            value: document.querySelector('#co-owners .metric-value')
                        },
                        regulators: {
                            meter: document.querySelector('#regulators .meter'),
                            value: document.querySelector('#regulators .metric-value')
                        },
                        government: {
                            meter: document.querySelector('#government .meter'),
                            value: document.querySelector('#government .metric-value')
                        },
                        securityHolders: {
                            meter: document.querySelector('#security-holders .meter'),
                            value: document.querySelector('#security-holders .metric-value')
                        }
                    },
                    scenario: {
                        title: document.getElementById('scenario-title'),
                        description: document.getElementById('scenario-description'),
                        image: document.getElementById('scenario-image'),
                        moneyCost: document.getElementById('scenario-money-cost'),
                        moneyCostValue: document.getElementById('money-cost-value'),
                        choicesContainer: document.getElementById('choices-container')
                    },
                    yearDisplay: document.getElementById('year'),
                    weekDisplay: document.getElementById('week'),
                    moneyValue: document.getElementById('money-value'),
                    newsFeed: {
                        container: document.getElementById('news-feed-container'),
                        content: document.getElementById('news-feed-content'),
                        toggle: document.getElementById('news-feed-toggle')
                    },
                    overlays: {
                        menu: document.getElementById('menu-overlay'),
                        stats: document.getElementById('stats-overlay'),
                        bonuses: document.getElementById('bonuses-overlay'),
                        flags: document.getElementById('flags-overlay'),
                        scenarioPacks: document.getElementById('scenario-packs-overlay'),
                        yearReport: document.getElementById('year-report-overlay'),
                        moneyCrisis: document.getElementById('money-crisis-overlay')
                    },
                    yearReport: {
                        year: document.getElementById('annual-report-year'),
                        content: document.getElementById('annual-report-content'),
                        distributionSection: document.getElementById('distribution-decision'),
                        distributionOptions: document.getElementById('distribution-options')
                    },
                    gameOver: {
                        reason: document.getElementById('game-over-reason'),
                        stats: document.getElementById('final-stats-content'),
                        yearsSurvived: document.getElementById('years-survived')
                    },
                    notification: document.getElementById('notification'),
                    notificationMessage: document.getElementById('notification-message')
                };
                
                this.setupEventListeners();
            }

            // Initialize the game
            async init() {
                try {
                    // Load extension scenarios first
                    await this.loadScenarioExtensions();
                    
                    // Load base scenarios (now will incorporate extensions)
                    await this.loadScenarios();
                    
                    // Load any additional game resources
                    await this.loadExtras();
                    
                    // Setup event listeners
                    this.setupEventListeners();
                    
                    // Show start screen
                    this.showScreen('start');
                } catch (error) {
                    console.error('Game initialization error:', error);
                    this.showNotification('Failed to initialize game. Please refresh the page.');
                }
            }

            // Helper method to load extension files from a list
            async loadExtensionFiles(fileList) {
                const loadPromises = fileList.map(file => {
                    return new Promise((resolve) => {
                        const script = document.createElement('script');
                        script.src = file;
                        
                        script.onload = () => {
                            console.log(`Successfully loaded scenario extension: ${file}`);
                            resolve(true);
                        };
                        
                        script.onerror = () => {
                            console.warn(`Failed to load scenario extension: ${file}`);
                            resolve(false);
                        };
                        
                        document.head.appendChild(script);
                    });
                });
                
                await Promise.all(loadPromises);
            }

            // Helper method to try loading extensions by common naming patterns
            async loadExtensionsByPattern() {
                // Try these common extension names
                const extensionPatterns = [
                    'scenarios-expansion.js',
                    'scenarios-corporate.js',
                    'scenarios-crisis.js',
                    'scenarios-custom.js'
                ];
                
                await this.loadExtensionFiles(extensionPatterns);
            }

            // Load scenario extensions
            async loadScenarioExtensions() {
                // Create a global container for extension registrations if it doesn't exist
                if (!window.gameScenarioExtensions) {
                    window.gameScenarioExtensions = [];
                }
                
                // Look for an extensions manifest file first
                try {
                    const manifestScript = document.createElement('script');
                    manifestScript.src = 'scenario-extensions.manifest.js';
                    
                    await new Promise((resolve, reject) => {
                        manifestScript.onload = resolve;
                        manifestScript.onerror = reject;
                        document.head.appendChild(manifestScript);
                    });
                    
                    // If manifest is loaded, it should have populated window.scenarioExtensionsList
                    if (window.scenarioExtensionsList && Array.isArray(window.scenarioExtensionsList)) {
                        console.log('Loading extensions from manifest:', window.scenarioExtensionsList);
                        await this.loadExtensionFiles(window.scenarioExtensionsList);
                    }
                } catch (e) {
                    console.log('No extension manifest found, looking for extension files with naming pattern');
                    // Fall back to trying common extension patterns
                    await this.loadExtensionsByPattern();
                }
            }

            // Load scenarios from external files
            async loadScenarios() {
                try {
                    // Initialize array for all scenarios
                    let allScenarios = [];
                    
                    // First load base scenarios from scenarios.js
                    if (window.gameScenarios) {
                        allScenarios = [...window.gameScenarios];
                        console.log(`Loaded ${allScenarios.length} base scenarios`);
                    } else {
                        console.warn('Failed to load scenarios.js, using fallback scenarios');
                        // Use existing fallback scenarios
                        allScenarios = this.getFallbackScenarios();
                    }
                    
                    // Then incorporate any extension scenarios that have been registered
                    if (window.gameScenarioExtensions && window.gameScenarioExtensions.length > 0) {
                        console.log(`Found ${window.gameScenarioExtensions.length} scenario extensions`);
                        for (const extension of window.gameScenarioExtensions) {
                            console.log(`Loading scenario extension: ${extension.name} (${extension.scenarios.length} scenarios)`);
                            allScenarios = [...allScenarios, ...extension.scenarios];
                        }
                    }
                    
                    // Add starting scenario
                    allScenarios.push(this.getStartingScenario());
                    
                    // Set the combined scenarios
                    this.scenarioManager.setScenarios(allScenarios);
                    console.log(`Total scenarios loaded: ${allScenarios.length}`);
                    
                } catch (error) {
                    console.error('Error loading scenarios:', error);
                    throw error;
                }
            }

            // Get the starting scenario
            getStartingScenario() {
                return {
                    id: "starting_scenario",
                    title: "Your First Day as Executive",
                    description: "As you settle into your new office at Pretty Close Centres, the board has asked you to establish your strategic priorities for the coming years. Your initial direction will set the tone for your leadership.",
                    image: "office.jpg",
                    choices: [
                        {
                            text: "Focus on financial growth and shareholder returns",
                            explanation: "You pledge to prioritize revenue growth and returns to shareholders above all else.",
                            outcome: {
                                metrics: { revenue: 10, employee_engagement: 3, customer_satisfaction: -5 },
                                values: { excellence: 5, customer_focus: -3, integrity: -2 },
                                factions: { security_holders: 10, banks: 8, regulators: -5 },
                                flags: ["The company prioritizes financial performance.", "The company is shareholder focused."]
                            }
                        },
                        {
                            text: "Build a balanced business with strong stakeholder relationships",
                            explanation: "You commit to a balanced approach that considers all stakeholders in your decision making.",
                            outcome: {
                                metrics: { revenue: 5, employee_engagement: 5, customer_satisfaction: 5 },
                                values: { respect: 5, integrity: 5, collaboration: 5, customer_focus: 5, excellence: 5 },
                                factions: { security_holders: 5, co_owners: 5, regulators: 5, government: 5, banks: 5 },
                                flags: ["The company takes a balanced approach to stakeholders."]
                            }
                        },
                        {
                            text: "Establish a purpose-driven organization focused on community impact",
                            explanation: "You declare that Pretty Close Centres will measure success by its positive impact on communities and society.",
                            outcome: {
                                metrics: { revenue: -5, employee_engagement: 10, customer_satisfaction: 10 },
                                values: { respect: 8, integrity: 8, customer_focus: 7, collaboration: 5, excellence: 2 },
                                factions: { government: 10, regulators: 7, co_owners: 5, security_holders: -8 },
                                flags: ["The company has become purpose driven.", "The company prioritizes social impact."]
                            }
                        }
                    ]
                };
            }

            // Move fallback scenarios to a separate method for clarity
            getFallbackScenarios() {
                return [
                    {
                        id: "new_shopping_centre",
                        title: "New Shopping Centre Development",
                        description: "You have an opportunity to develop a new shopping centre in a growing suburb.",
                        image: "construction.jpg",
                        choices: [
                            {
                                text: "Focus on premium retailers for higher margins",
                                outcome: {
                                    metrics: { revenue: 5, customer_satisfaction: -2 },
                                    values: { excellence: 3, customer_focus: -1 },
                                    factions: { security_holders: 3, co_owners: 2 },
                                    moneyCost: 5000000
                                }
                            },
                            {
                                text: "Create a balanced mix of retailers",
                                outcome: {
                                    metrics: { revenue: 3, customer_satisfaction: 3 },
                                    values: { collaboration: 2, customer_focus: 2 },
                                    factions: { co_owners: 3, regulators: 1 },
                                    moneyCost: 3500000
                                }
                            },
                            {
                                text: "Prioritize community needs with affordable options",
                                outcome: {
                                    metrics: { revenue: 1, customer_satisfaction: 5 },
                                    values: { respect: 3, integrity: 2 },
                                    factions: { government: 3, regulators: 2, security_holders: -1 },
                                    moneyCost: 2000000
                                }
                            }
                        ]
                    },
                    {
                        id: "employee_feedback",
                        title: "Employee Feedback Initiative",
                        description: "HR has proposed a new feedback system for employees to voice concerns anonymously.",
                        image: "office.jpg",
                        choices: [
                            {
                                text: "Implement the system fully",
                                outcome: {
                                    metrics: { employee_engagement: 5, revenue: -1 },
                                    values: { respect: 3, integrity: 3, collaboration: 2 },
                                    moneyCost: 500000
                                }
                            },
                            {
                                text: "Implement a limited version with oversight",
                                outcome: {
                                    metrics: { employee_engagement: 2 },
                                    values: { respect: 1, collaboration: 1 },
                                    moneyCost: 250000
                                }
                            },
                            {
                                text: "Reject the proposal as unnecessary",
                                outcome: {
                                    metrics: { employee_engagement: -3, revenue: 1 },
                                    values: { respect: -2, integrity: -1, collaboration: -2 }
                                }
                            }
                        ]
                    },
                    {
                        id: "regulatory_compliance",
                        title: "Regulatory Compliance Update",
                        description: "New environmental regulations will require significant updates to your properties.",
                        image: "regulation.jpg",
                        choices: [
                            {
                                text: "Exceed compliance requirements",
                                outcome: {
                                    metrics: { revenue: -3 },
                                    values: { integrity: 3, excellence: 2 },
                                    factions: { regulators: 5, government: 3, banks: -1 },
                                    moneyCost: 2000000
                                }
                            },
                            {
                                text: "Meet minimum requirements efficiently",
                                outcome: {
                                    metrics: { revenue: -1 },
                                    values: { integrity: 1 },
                                    factions: { regulators: 2, government: 1 },
                                    moneyCost: 1000000
                                }
                            },
                            {
                                text: "Lobby for deadline extensions",
                                outcome: {
                                    metrics: { revenue: 2 },
                                    values: { integrity: -2 },
                                    factions: { regulators: -3, government: -2, security_holders: 1 },
                                    moneyCost: 500000
                                }
                            }
                        ]
                    }
                ];
            }

            // Load extra features
            async loadExtras() {
                try {
                    // Check if the extras script is available
                    if (window.gameBonuses) {
                        // Initialize bonuses
                        this.bonuses = window.gameBonuses;
                    } else {
                        // Create fallback bonuses
                        this.bonuses = {
                            revenue_max: {
                                name: "Financial Excellence",
                                description: "Your strong financial performance attracts better financing terms.",
                                effect: "Reduced impact from negative revenue events."
                            },
                            employeeEngagement_max: {
                                name: "Employer of Choice",
                                description: "Your company is recognized as a top workplace.",
                                effect: "Employee engagement drops more slowly over time."
                            },
                            customerSatisfaction_max: {
                                name: "Customer Champion",
                                description: "Your centers are beloved by shoppers.",
                                effect: "Customer satisfaction provides revenue bonuses."
                            }
                        };
                    }
                } catch (error) {
                    console.error('Error loading extras:', error);
                    // Continue without extras
                    this.bonuses = {};
                }
            }

            // Setup event listeners
            setupEventListeners() {
                // Start button
                document.getElementById('start-button').addEventListener('click', () => {
                    this.start();
                });
                
                // Load button
                document.getElementById('load-button').addEventListener('click', () => {
                    this.loadGame();
                });
                
                // Restart button
                document.getElementById('restart-button').addEventListener('click', () => {
                    this.start();
                });
                
                // Main menu button
                document.getElementById('main-menu-button').addEventListener('click', () => {
                    this.showScreen('start');
                });
                
                // Menu button
                document.getElementById('menu-button').addEventListener('click', () => {
                    this.toggleOverlay('menu');
                });
                
                // Close menu button
                document.getElementById('close-menu-button').addEventListener('click', () => {
                    this.hideOverlay('menu');
                });
                
                // Save game button
                document.getElementById('save-game-button').addEventListener('click', () => {
                    this.saveGame();
                    this.hideOverlay('menu');
                });
                
                // Menu load button
                document.getElementById('menu-load-button').addEventListener('click', () => {
                    this.loadGame();
                    this.hideOverlay('menu');
                });
                
                // View stats button
                document.getElementById('view-stats-button').addEventListener('click', () => {
                    this.showStats();
                    this.hideOverlay('menu');
                });
                
                // View bonuses button
                document.getElementById('view-bonuses-button').addEventListener('click', () => {
                    this.showBonuses();
                    this.hideOverlay('menu');
                });
                
                // View flags button
                document.getElementById('view-flags-button').addEventListener('click', () => {
                    this.showFlags();
                    this.hideOverlay('menu');
                });
                
                // View scenario packs button
                document.getElementById('view-scenario-packs-button').addEventListener('click', () => {
                    this.showScenarioPacks();
                    this.hideOverlay('menu');
                });
                
                // Close stats button
                document.getElementById('close-stats-button').addEventListener('click', () => {
                    this.hideOverlay('stats');
                });
                
                // Close bonuses button
                document.getElementById('close-bonuses-button').addEventListener('click', () => {
                    this.hideOverlay('bonuses');
                });
                
                // Close flags button
                document.getElementById('close-flags-button').addEventListener('click', () => {
                    this.hideOverlay('flags');
                });
                
                // Close scenario packs button
                document.getElementById('close-scenario-packs-button').addEventListener('click', () => {
                    this.hideOverlay('scenarioPacks');
                });
                
                // Quit button
                document.getElementById('quit-button').addEventListener('click', () => {
                    this.quit();
                });
                
                // Continue to next year button
                document.getElementById('continue-year-button').addEventListener('click', () => {
                    this.hideOverlay('yearReport');
                    this.awaitingYearEnd = false;
                    this.nextScenario();
                });
                
                // News feed toggle
                this.elements.newsFeed.toggle.addEventListener('click', () => {
                    this.toggleNewsFeed();
                });
                
                // Money crisis options
                document.getElementById('raise-debt-button').addEventListener('click', () => {
                    this.handleMoneyCrisis('debt');
                });
                
                document.getElementById('raise-equity-button').addEventListener('click', () => {
                    this.handleMoneyCrisis('equity');
                });
                
                document.getElementById('sell-assets-button').addEventListener('click', () => {
                    this.handleMoneyCrisis('assets');
                });
                
                // Collapsible sections
                document.querySelectorAll('.metric-group h3').forEach(header => {
                    header.addEventListener('click', () => {
                        const group = header.parentElement;
                        group.classList.toggle('collapsed');
                    });
                });
            }

            // Toggle news feed expanded/collapsed state
            toggleNewsFeed() {
                const container = this.elements.newsFeed.container;
                const toggle = this.elements.newsFeed.toggle;
                
                container.classList.toggle('expanded');
                
                if (container.classList.contains('expanded')) {
                    toggle.textContent = '▼';
                } else {
                    toggle.textContent = '▲';
                }
            }

            // Update the news feed display
            updateNewsFeed() {
                const feedContent = this.elements.newsFeed.content;
                const entries = this.gameState.newsFeed;
                
                // Clear existing entries
                feedContent.innerHTML = '';
                
                // Add latest entries
                entries.slice(0, 20).forEach(entry => {
                    const entryElement = document.createElement('div');
                    entryElement.className = 'news-entry';
                    
                    const dateElement = document.createElement('span');
                    dateElement.className = 'news-date';
                    dateElement.textContent = `Year ${entry.year}, Week ${entry.week}`;
                    
                    const titleElement = document.createElement('h4');
                    titleElement.textContent = entry.title;
                    
                    const decisionElement = document.createElement('p');
                    decisionElement.className = 'news-decision';
                    decisionElement.textContent = entry.decision || '';
                    
                    const impactsContainer = document.createElement('div');
                    impactsContainer.className = 'news-impacts';
                    
                    if (entry.impacts && entry.impacts.length > 0) {
                        const impactsList = document.createElement('ul');
                        entry.impacts.forEach(impact => {
                            const impactItem = document.createElement('li');
                            impactItem.textContent = impact;
                            impactsList.appendChild(impactItem);
                        });
                        impactsContainer.appendChild(impactsList);
                    }
                    
                    entryElement.appendChild(dateElement);
                    entryElement.appendChild(titleElement);
                    if (entry.decision) {
                        entryElement.appendChild(decisionElement);
                    }
                    if (entry.impacts && entry.impacts.length > 0) {
                        entryElement.appendChild(impactsContainer);
                    }
                    
                    feedContent.appendChild(entryElement);
                });
            }

            // Handle money crisis
            handleMoneyCrisis(option) {
                const result = this.gameState.handleFinancialCrisis(option);
                
                if (result.success) {
                    this.showNotification(result.message);
                    this.updateUI();
                    this.hideOverlay('moneyCrisis');
                    this.awaitingMoneyCrisis = false;
                    
                    // Check if we were also awaiting year end
                    if (this.awaitingYearEnd) {
                        this.showYearEndReport();
                    } else {
                        this.nextScenario();
                    }
                } else {
                    this.showNotification("Error: " + result.message);
                }
            }

            // Show the flags overlay
            showFlags() {
                const flagsElement = document.getElementById('flags-content');
                flagsElement.innerHTML = this.generateFlagsHTML();
                this.showOverlay('flags');
            }

            // Generate HTML for flags display
            generateFlagsHTML() {
                const flags = this.gameState.flags;
                let flagsHTML = '<div class="flags-list">';
                
                const flagsList = Object.keys(flags);
                
                if (flagsList.length > 0) {
                    flagsHTML += '<ul>';
                    for (const flag of flagsList) {
                        flagsHTML += `<li>${flag}</li>`;
                    }
                    flagsHTML += '</ul>';
                } else {
                    flagsHTML += '<p>No active flags.</p>';
                }
                
                flagsHTML += '</div>';
                return flagsHTML;
            }

            // Show year end report
            showYearEndReport() {
                const previousYear = this.gameState.year - 1;
                const yearEndData = this.gameState.stats.metricHistory[previousYear];
                
                if (!yearEndData) {
                    console.error('No year-end data available for year', previousYear);
                    this.awaitingYearEnd = false;
                    this.nextScenario();
                    return;
                }
                
                // Set year in report
                this.elements.yearReport.year.textContent = previousYear;
                
                // Generate report content
                let reportHTML = '<div class="annual-report">';
                
                // Performance summary
                reportHTML += `<h3>Performance Summary - Year ${previousYear}</h3>`;
                reportHTML += '<div class="report-section">';
                
                // Core metrics
                reportHTML += '<h4>Core Business Metrics</h4>';
                reportHTML += '<table class="report-table">';
                reportHTML += '<tr><th>Metric</th><th>End of Year</th><th>Change</th></tr>';
                
                for (const [metric, value] of Object.entries(yearEndData.metrics)) {
                    const startValue = previousYear === 1 ? 50 : this.gameState.stats.metricHistory[previousYear - 1].metrics[metric];
                    const change = value - startValue;
                    const changeClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    
                    reportHTML += `
                        <tr>
                            <td>${this.gameState.getDisplayName(metric)}</td>
                            <td>${value.toFixed(1)}</td>
                            <td class="${changeClass}">${change > 0 ? '+' : ''}${change.toFixed(1)}</td>
                        </tr>
                    `;
                }
                
                reportHTML += '</table>';
                
                // Corporate values
                reportHTML += '<h4>Corporate Values</h4>';
                reportHTML += '<table class="report-table">';
                reportHTML += '<tr><th>Value</th><th>End of Year</th><th>Change</th></tr>';
                
                for (const [value, rating] of Object.entries(yearEndData.values)) {
                    const startValue = previousYear === 1 ? 50 : this.gameState.stats.metricHistory[previousYear - 1].values[value];
                    const change = rating - startValue;
                    const changeClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    
                    reportHTML += `
                        <tr>
                            <td>${this.gameState.getDisplayName(value)}</td>
                            <td>${rating.toFixed(1)}</td>
                            <td class="${changeClass}">${change > 0 ? '+' : ''}${change.toFixed(1)}</td>
                        </tr>
                    `;
                }
                
                reportHTML += '</table>';
                
                // Faction relationships
                reportHTML += '<h4>Stakeholder Relationships</h4>';
                reportHTML += '<table class="report-table">';
                reportHTML += '<tr><th>Stakeholder</th><th>End of Year</th><th>Change</th></tr>';
                
                for (const [faction, rating] of Object.entries(yearEndData.factions)) {
                    const startValue = previousYear === 1 ? 50 : this.gameState.stats.metricHistory[previousYear - 1].factions[faction];
                    const change = rating - startValue;
                    const changeClass = change > 0 ? 'positive' : (change < 0 ? 'negative' : 'neutral');
                    
                    reportHTML += `
                        <tr>
                            <td>${this.gameState.getDisplayName(faction)}</td>
                            <td>${rating.toFixed(1)}</td>
                            <td class="${changeClass}">${change > 0 ? '+' : ''}${change.toFixed(1)}</td>
                        </tr>
                    `;
                }
                
                reportHTML += '</table>';
                
                // Financial summary
                const yearEndMoney = this.gameState.stats.moneyHistory[previousYear] || 0;
                const startMoney = previousYear === 1 ? 10000000 : this.gameState.stats.moneyHistory[previousYear - 1] || 0;
                const moneyChange = yearEndMoney - startMoney;
                const moneyChangeClass = moneyChange > 0 ? 'positive' : (moneyChange < 0 ? 'negative' : 'neutral');
                
                reportHTML += '<h4>Financial Summary</h4>';
                reportHTML += `<p>Year-end cash position: $${this.gameState.formatMoney(yearEndMoney)}</p>`;
                reportHTML += `<p>Cash flow for year: <span class="${moneyChangeClass}">$${moneyChange > 0 ? '+' : ''}${this.gameState.formatMoney(moneyChange)}</span></p>`;
                
                reportHTML += '</div>';
                
                // Set the report content
                this.elements.yearReport.content.innerHTML = reportHTML;
                
                // Set up the distribution decision
                this.setupDistributionOptions();
                
                // Show the overlay
                this.showOverlay('yearReport');
            }

            // Setup distribution options
            setupDistributionOptions() {
                const distributionSection = this.elements.yearReport.distributionSection;
                const optionsContainer = this.elements.yearReport.distributionOptions;
                
                // Only show distribution options if we have enough cash
                if (this.gameState.money < 500000) {
                    distributionSection.classList.add('hidden');
                    return;
                }
                
                distributionSection.classList.remove('hidden');
                
                // Calculate expected distribution based on revenue
                const expectedDistribution = (this.gameState.metrics.revenue / 100) * 2000000;
                const availableMoney = this.gameState.money;
                
                // Create options
                let optionsHTML = '';
                
                // Zero option
                optionsHTML += `
                    <button class="distribution-option" data-amount="0">
                        <span class="option-amount">$0</span>
                        <span class="option-description">No distribution</span>
                        <span class="option-impact negative">Security holders -3</span>
                    </button>
                `;
                
                // Low option (if affordable)
                if (availableMoney >= expectedDistribution * 0.5) {
                    optionsHTML += `
                        <button class="distribution-option" data-amount="${Math.floor(expectedDistribution * 0.5)}">
                            <span class="option-amount">$${this.gameState.formatMoney(expectedDistribution * 0.5)}</span>
                            <span class="option-description">Below expectations</span>
                            <span class="option-impact negative">Security holders -1</span>
                        </button>
                    `;
                }
                
                // Standard option (if affordable)
                if (availableMoney >= expectedDistribution) {
                    optionsHTML += `
                        <button class="distribution-option" data-amount="${Math.floor(expectedDistribution)}">
                            <span class="option-amount">$${this.gameState.formatMoney(expectedDistribution)}</span>
                            <span class="option-description">Meet expectations</span>
                            <span class="option-impact positive">Security holders +3</span>
                        </button>
                    `;
                }
                
                // Generous option (if affordable)
                if (availableMoney >= expectedDistribution * 1.5) {
                    optionsHTML += `
                        <button class="distribution-option" data-amount="${Math.floor(expectedDistribution * 1.5)}">
                            <span class="option-amount">$${this.gameState.formatMoney(expectedDistribution * 1.5)}</span>
                            <span class="option-description">Exceed expectations</span>
                            <span class="option-impact positive">Security holders +5</span>
                        </button>
                    `;
                }
                
                optionsContainer.innerHTML = optionsHTML;
                
                // Add event listeners to the options
                document.querySelectorAll('.distribution-option').forEach(button => {
                    button.addEventListener('click', () => {
                        const amount = parseInt(button.getAttribute('data-amount'));
                        this.makeDistribution(amount);
                    });
                });
            }

            // Make a distribution to security holders
            makeDistribution(amount) {
                const result = this.gameState.makeDistribution(amount);
                
                if (result.success) {
                    this.showNotification(result.message);
                    
                    // Hide the distribution section after decision is made
                    this.elements.yearReport.distributionSection.classList.add('hidden');
                    
                    // Update UI
                    this.updateUI();
                } else {
                    this.showNotification("Error: " + result.message);
                }
            }

            // Start a new game
            start() {
                this.gameState = new GameState();
                this.scenarioManager = new ScenarioManager(this.gameState);
                
                // Load all scenarios including extensions
                let allScenarios = [];
                
                // Add base scenarios
                if (window.gameScenarios) {
                    allScenarios = [...window.gameScenarios];
                }
                
                // Add extension scenarios
                if (window.gameScenarioExtensions) {
                    for (const extension of window.gameScenarioExtensions) {
                        allScenarios = [...allScenarios, ...extension.scenarios];
                    }
                }
                
                // Add starting scenario
                allScenarios.push(this.getStartingScenario());
                
                // If no scenarios, use fallbacks
                if (allScenarios.length === 0) {
                    allScenarios = this.getFallbackScenarios();
                }
                
                this.scenarioManager.setScenarios(allScenarios);
                this.isRunning = true;
                this.awaitingYearEnd = false;
                this.awaitingMoneyCrisis = false;
                
                this.showScreen('game');
                this.updateUI();
                this.nextScenario();
            }

            // Load a saved game
            loadGame() {
                if (this.gameState.load()) {
                    this.scenarioManager = new ScenarioManager(this.gameState);
                    
                    // Load all scenarios including extensions
                    let allScenarios = [];
                    
                    // Add base scenarios
                    if (window.gameScenarios) {
                        allScenarios = [...window.gameScenarios];
                    }
                    
                    // Add extension scenarios
                    if (window.gameScenarioExtensions) {
                        for (const extension of window.gameScenarioExtensions) {
                            allScenarios = [...allScenarios, ...extension.scenarios];
                        }
                    }
                    
                    // Add starting scenario
                    allScenarios.push(this.getStartingScenario());
                    
                    // If no scenarios, use fallbacks
                    if (allScenarios.length === 0) {
                        allScenarios = this.getFallbackScenarios();
                    }
                    
                    this.scenarioManager.setScenarios(allScenarios);
                    this.isRunning = true;
                    this.awaitingYearEnd = false;
                    this.awaitingMoneyCrisis = false;
                    
                    this.showScreen('game');
                    this.updateUI();
                    this.nextScenario();
                    
                    this.showNotification('Game loaded successfully!');
                } else {
                    this.showNotification('No saved game found.');
                }
            }

            // Save the current game
            saveGame() {
                if (this.gameState.save()) {
                    this.showNotification('Game saved successfully!');
                    return true;
                } else {
                    this.showNotification('Failed to save game.');
                    return false;
                }
            }

            // Quit to main menu
            quit() {
                this.isRunning = false;
                this.hideOverlay('menu');
                this.showScreen('start');
            }

            // Show stats overlay
            showStats() {
                const statsElement = document.getElementById('stats-content');
                statsElement.innerHTML = this